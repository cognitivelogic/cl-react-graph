{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es.math.hypot.js","webpack:///../node_modules/react-use-gesture/dist/react-use-gesture.esm.js","webpack:///../src/components/Brush.tsx","webpack:///./src/pages/brush.tsx","webpack:///../test/fixtures.ts"],"names":["$","$hypot","Math","hypot","abs","sqrt","target","stat","forced","Infinity","NaN","value1","value2","arg","div","sum","i","aLen","arguments","length","larg","addV","v1","v2","map","v","subV","calculateDistance","movement","apply","calculateAllKinematics","delta","dt","dl","alpha","beta","velocity","velocities","direction","distance","sign","x","Number","rubberband","dimension","constant","pow","rubberband2","rubberbandIfOutOfBounds","position","min","max","value","minMax","_defineProperties","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_extends","assign","source","prototype","hasOwnProperty","call","this","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_objectWithoutPropertiesLoose","excluded","sourceKeys","keys","indexOf","_assertThisInitialized","self","ReferenceError","_arrayLikeToArray","arr","len","arr2","Array","_createForOfIteratorHelperLoose","o","allowArrayLike","it","Symbol","iterator","isArray","minLen","n","toString","slice","name","from","test","_unsupportedIterableToArray","done","TypeError","next","bind","noop","chainFns","_len","fns","_key","result","_step","_iterator","fn","ensureVector","fallback","undefined","Error","valueFn","_len2","args","_key2","resolveWith","config","resolvers","_i","_Object$entries","entries","_Object$entries$_i","resolver","InternalGestureOptionsNormalizers","threshold","enabled","triggerAllEvents","initial","InternalCoordinatesOptionsNormalizers","axis","lockDirection","bounds","state","_value2","_value2$left","left","_value2$right","right","_value2$top","top","_value2$bottom","bottom","isBrowser","window","document","createElement","InternalGenericOptionsNormalizers","domTarget","_window","_x","eventOptions","_temp","_ref","_ref$passive","passive","_ref$capture","capture","InternalDragOptionsNormalizers","_k","_ref3","_ref3$filterTaps","filterTaps","_ref3$lockDirection","_ref3$axis","A","swipeVelocity","swipeDistance","delay","getInternalGenericOptions","getInternalDragOptions","_buildDragConfig","rest","opts","drag","getInitial","mixed","_active","_blocked","_intentional","_movement","_initial","_bounds","_lastEventType","event","intentional","values","offset","lastOffset","previous","first","last","active","timeStamp","startTime","elapsedTime","cancel","canceled","memo","getInitialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","touches","buttons","down","shiftKey","altKey","metaKey","ctrlKey","xy","vxvy","_isTap","_delayedEvent","_pointerId","tap","swipe","pinch","da","vdva","origin","turns","wheel","move","scroll","RecognizersMap","Map","Recognizer","controller","_this","debounced","setTimeout","callback","ms","clearTimeout","timeouts","stateKey","concat","fireGestureHandler","forceFlag","clean","prev_active","next_active","ingKey","mapStateValues","newMemo","handler","Constructor","protoProps","staticProps","_proto","updateSharedState","sharedState","updateGestureState","gestureState","checkIntentionality","getMovement","_this$config","T","_this$state","wasIntentional","prevMovement","M","getInternalMovement","i0","getIntentionalDisplacement","i1","intentionalityCheck","__cachedBounds","__cachedInitial","_cachedInitial","_cachedBounds","_rubberband","computeRubberband","get","handlers","_ref2","Vx","Vy","Rx","Ry","_bounds$","X1","X2","_bounds$2","Y1","Y2","getGenericPayload","isStartEvent","type","getStartGestureState","recognizer","partial","func","Controller","classes","bindings","RecognizerClass","addBindings","nativeRefs","updateDomListeners","getPropsListener","effect","getDomTargetFromConfig","removeListeners","takeAll","domListeners","forEach","_controller$config","el","windowListeners","clearAllWindowListeners","clearWindowListeners","updateWindowListeners","listeners","addListeners","_i2","_Object$entries2","_Object$entries2$_i","toLowerCase","push","_ref4","captureString","_i3","_Object$entries3","_Object$entries3$_i","fnsArray","array","splice","_ref5","current","options","_step2","_iterator2","_step2$value","eventName","eventHandler","addEventListener","_step3","_iterator3","_step3$value","removeEventListener","useRecognizers","nativeHandlers","internalHandlers","Set","add","hover","resolveClasses","useMemo","useEffect","deprecationNoticeForDomTarget","CoordinatesRecognizer","_Recognizer","_movement$map","absX","absY","getKinematics","getTouchEvents","targetTouches","changedTouches","getGenericEventData","touchEvents","getPointerEventValues","clientX","clientY","DragRecognizer","_CoordinatesRecognize","onDragStart","onDragChange","onDragEnd","pointerId","persist","startDrag","genericEventData","kinematics","genericPayload","realDistance","_this$state$velocitie","vx","vy","_this$state$movement","mx","my","_this$state$_intentio","ix","iy","_this$config$swipeVel","svx","svy","_this$config$swipeDis","sx","sy","endState","onCancel","requestAnimationFrame","onClick","stopPropagation","memoizeOne","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","a","b","equal","size","has","RegExp","flags","valueOf","Element","$$typeof","error","message","match","console","warn","useDrag","set","buildDragConfig","Container","children","height","width","fill","Brush","onChange","brushWidth","chart","initialPosition","start","y","w","useState","end","bindResizeLeft","bindResizeRight","transform","rect","style","cursor","opacity","dateFormat","scale","label","numberFormat","filterData","pos","data","data3","line","LineExample","scaleTime","domain","range","filter","brushedData","setBrushedData","title","description","Typography","variant","Grid","container","spacing","item","xs","Card","CardContent","Line","animate","makeBrushedData","now","Date","dateValues","_","setDate","getDate","random","curveCatmullRom"],"mappings":"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","file":"component---src-pages-brush-tsx-a44029a0dafcad3af2b8.js","sourcesContent":["var $ = require('../internals/export');\n\nvar $hypot = Math.hypot;\nvar abs = Math.abs;\nvar sqrt = Math.sqrt;\n\n// Chrome 77 bug\n// https://bugs.chromium.org/p/v8/issues/detail?id=9546\nvar BUGGY = !!$hypot && $hypot(Infinity, NaN) !== Infinity;\n\n// `Math.hypot` method\n// https://tc39.github.io/ecma262/#sec-math.hypot\n$({ target: 'Math', stat: true, forced: BUGGY }, {\n  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars\n    var sum = 0;\n    var i = 0;\n    var aLen = arguments.length;\n    var larg = 0;\n    var arg, div;\n    while (i < aLen) {\n      arg = abs(arguments[i++]);\n      if (larg < arg) {\n        div = larg / arg;\n        sum = sum * div * div + 1;\n        larg = arg;\n      } else if (arg > 0) {\n        div = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * sqrt(sum);\n  }\n});\n","import \"core-js/modules/es.math.hypot.js\";\nimport React, { useRef } from 'react'; // vector add\n\nfunction addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n} // vector substract\n\n\nfunction subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n}\n/**\r\n * Calculates distance\r\n * @param movement the difference between current and initial vectors\r\n * @returns distance\r\n */\n\n\nfunction calculateDistance(movement) {\n  return Math.hypot.apply(Math, movement);\n}\n\nfunction calculateAllGeometry(movement, delta) {\n  if (delta === void 0) {\n    delta = movement;\n  }\n\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param movement the difference between current and initial vectors\r\n * @param delta the difference between current and previous vectors\r\n * @param delta_t the time difference between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\n\nfunction calculateAllKinematics(movement, delta, dt) {\n  var dl = calculateDistance(delta);\n  var alpha = dl === 0 ? 0 : 1 / dl;\n  var beta = dt === 0 ? 0 : 1 / dt;\n  var velocity = beta * dl;\n  var velocities = delta.map(function (v) {\n    return beta * v;\n  });\n  var direction = delta.map(function (v) {\n    return alpha * v;\n  });\n  var distance = calculateDistance(movement);\n  return {\n    velocities: velocities,\n    velocity: velocity,\n    distance: distance,\n    direction: direction\n  };\n}\n/**\r\n * Because IE doesn't support `Math.sign` function, so we use the polyfill version of the function.\r\n * This polyfill function is suggested by Mozilla:\r\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\r\n * @param x target number\r\n */\n\n\nfunction sign(x) {\n  if (Math.sign) return Math.sign(x);\n  return Number(x > 0) - Number(x < 0) || +x;\n}\n\nfunction minMax(value, min, max) {\n  return Math.max(min, Math.min(value, max));\n} // Based on @aholachek ;)\n// https://twitter.com/chpwn/status/285540192096497664\n// iOS constant = 0.55\n// https://medium.com/@nathangitter/building-fluid-interfaces-ios-swift-9732bb934bf5\n\n\nfunction rubberband2(distance, constant) {\n  // default constant from the article is 0.7\n  return Math.pow(distance, constant * 5);\n}\n\nfunction rubberband(distance, dimension, constant) {\n  if (dimension === 0 || Math.abs(dimension) === Infinity) return rubberband2(distance, constant);\n  return distance * dimension * constant / (dimension + constant * distance);\n}\n\nfunction rubberbandIfOutOfBounds(position, min, max, constant) {\n  if (constant === void 0) {\n    constant = 0.15;\n  }\n\n  if (constant === 0) return minMax(position, min, max);\n  if (position < min) return -rubberband(min - position, max - min, constant) + min;\n  if (position > max) return +rubberband(position - max, max - min, constant) + max;\n  return position;\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it;\n\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n      return function () {\n        if (i >= o.length) return {\n          done: true\n        };\n        return {\n          done: false,\n          value: o[i++]\n        };\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  it = o[Symbol.iterator]();\n  return it.next.bind(it);\n}\n\nfunction noop() {}\n/**\r\n * TODO Beware that only optimized cases are covered in tests =)\r\n * TODO Need to cover general case as well\r\n *\r\n * @param fns\r\n */\n\n\nfunction chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  if (fns.length === 0) return noop;\n  if (fns.length === 1) return fns[0];\n  return function () {\n    var result;\n\n    for (var _iterator = _createForOfIteratorHelperLoose(fns), _step; !(_step = _iterator()).done;) {\n      var fn = _step.value;\n      result = fn.apply(this, arguments) || result;\n    }\n\n    return result;\n  };\n}\n/**\r\n * Expects a simple value or 2D vector (an array with 2 elements) and\r\n * always returns 2D vector. If simple value is passed, returns a\r\n * vector with this value as both coordinates.\r\n *\r\n * @param value\r\n */\n\n\nfunction ensureVector(value, fallback) {\n  if (value === undefined) {\n    if (fallback === undefined) {\n      throw new Error('Must define fallback value if undefined is expected');\n    }\n\n    value = fallback;\n  }\n\n  if (Array.isArray(value)) return value;\n  return [value, value];\n}\n/**\r\n * Helper for defining a default value\r\n *\r\n * @param value\r\n * @param fallback\r\n */\n\n\nfunction assignDefault(value, fallback) {\n  return Object.assign({}, fallback, value || {});\n}\n/**\r\n * Resolves getters (functions) by calling them\r\n * If simple value is given it just passes through\r\n *\r\n * @param v\r\n */\n\n\nfunction valueFn(v) {\n  if (typeof v === 'function') {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    } // @ts-ignore\n\n\n    return v.apply(void 0, args);\n  } else {\n    return v;\n  }\n}\n\nfunction resolveWith(config, resolvers) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var result = {};\n\n  for (var _i = 0, _Object$entries = Object.entries(resolvers); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _Object$entries[_i],\n        key = _Object$entries$_i[0],\n        resolver = _Object$entries$_i[1];\n\n    switch (typeof resolver) {\n      case 'function':\n        result[key] = resolver.call(result, config[key], key, config);\n        break;\n\n      case 'object':\n        result[key] = resolveWith(config[key], resolver);\n        break;\n\n      case 'boolean':\n        if (resolver) result[key] = config[key];\n        break;\n    }\n  }\n\n  return result;\n}\n\nvar DEFAULT_DRAG_DELAY = 180;\nvar DEFAULT_RUBBERBAND = 0.15;\nvar DEFAULT_SWIPE_VELOCITY = 0.5;\nvar DEFAULT_SWIPE_DISTANCE = 60;\nvar InternalGestureOptionsNormalizers = {\n  threshold: function threshold(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    return ensureVector(value);\n  },\n  rubberband: function rubberband(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    switch (value) {\n      case true:\n        return ensureVector(DEFAULT_RUBBERBAND);\n\n      case false:\n        return ensureVector(0);\n\n      default:\n        return ensureVector(value);\n    }\n  },\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n\n    return value;\n  },\n  triggerAllEvents: function triggerAllEvents(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value;\n  },\n  initial: function initial(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    if (typeof value === 'function') return value;\n    return ensureVector(value);\n  }\n};\n\nvar InternalCoordinatesOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  axis: true,\n  lockDirection: function lockDirection(value) {\n    if (value === void 0) {\n      value = false;\n    }\n\n    return value;\n  },\n  bounds: function bounds(value) {\n    if (value === void 0) {\n      value = {};\n    }\n\n    if (typeof value === 'function') return function (state) {\n      return InternalCoordinatesOptionsNormalizers.bounds(value(state));\n    };\n    var _value2 = value,\n        _value2$left = _value2.left,\n        left = _value2$left === void 0 ? -Infinity : _value2$left,\n        _value2$right = _value2.right,\n        right = _value2$right === void 0 ? Infinity : _value2$right,\n        _value2$top = _value2.top,\n        top = _value2$top === void 0 ? -Infinity : _value2$top,\n        _value2$bottom = _value2.bottom,\n        bottom = _value2$bottom === void 0 ? Infinity : _value2$bottom;\n    return [[left, right], [top, bottom]];\n  }\n});\n\nvar isBrowser = typeof window !== 'undefined' && window.document && window.document.createElement;\nvar InternalGenericOptionsNormalizers = {\n  enabled: function enabled(value) {\n    if (value === void 0) {\n      value = true;\n    }\n\n    return value;\n  },\n  domTarget: true,\n  window: /*#__PURE__*/function (_window) {\n    function window(_x) {\n      return _window.apply(this, arguments);\n    }\n\n    window.toString = function () {\n      return _window.toString();\n    };\n\n    return window;\n  }(function (value) {\n    if (value === void 0) {\n      value = isBrowser ? window : undefined;\n    }\n\n    return value;\n  }),\n  eventOptions: function eventOptions(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        _ref$passive = _ref.passive,\n        passive = _ref$passive === void 0 ? true : _ref$passive,\n        _ref$capture = _ref.capture,\n        capture = _ref$capture === void 0 ? false : _ref$capture;\n\n    return {\n      passive: passive,\n      capture: capture\n    };\n  }\n};\n\nvar InternalDistanceAngleOptionsNormalizers = /*#__PURE__*/_extends({}, InternalGestureOptionsNormalizers, {\n  bounds: function bounds(_value, _key, _ref2) {\n    var _ref2$distanceBounds = _ref2.distanceBounds,\n        distanceBounds = _ref2$distanceBounds === void 0 ? {} : _ref2$distanceBounds,\n        _ref2$angleBounds = _ref2.angleBounds,\n        angleBounds = _ref2$angleBounds === void 0 ? {} : _ref2$angleBounds;\n\n    var _distanceBounds = function _distanceBounds(state) {\n      var D = assignDefault(valueFn(distanceBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [D.min, D.max];\n    };\n\n    var _angleBounds = function _angleBounds(state) {\n      var A = assignDefault(valueFn(angleBounds, state), {\n        min: -Infinity,\n        max: Infinity\n      });\n      return [A.min, A.max];\n    };\n\n    if (typeof distanceBounds !== 'function' && typeof angleBounds !== 'function') return [_distanceBounds(), _angleBounds()];\n    return function (state) {\n      return [_distanceBounds(state), _angleBounds(state)];\n    };\n  }\n});\n\nvar InternalDragOptionsNormalizers = /*#__PURE__*/_extends({}, InternalCoordinatesOptionsNormalizers, {\n  threshold: function threshold(v, _k, _ref3) {\n    var _ref3$filterTaps = _ref3.filterTaps,\n        filterTaps = _ref3$filterTaps === void 0 ? false : _ref3$filterTaps,\n        _ref3$lockDirection = _ref3.lockDirection,\n        lockDirection = _ref3$lockDirection === void 0 ? false : _ref3$lockDirection,\n        _ref3$axis = _ref3.axis,\n        axis = _ref3$axis === void 0 ? undefined : _ref3$axis;\n    var A = ensureVector(v, filterTaps ? 3 : lockDirection ? 1 : axis ? 1 : 0);\n    this.filterTaps = filterTaps || A[0] + A[1] > 0;\n    return A;\n  },\n  swipeVelocity: function swipeVelocity(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_VELOCITY;\n    }\n\n    return ensureVector(v);\n  },\n  swipeDistance: function swipeDistance(v) {\n    if (v === void 0) {\n      v = DEFAULT_SWIPE_DISTANCE;\n    }\n\n    return ensureVector(v);\n  },\n  delay: function delay(value) {\n    if (value === void 0) {\n      value = 0;\n    }\n\n    switch (value) {\n      case true:\n        return DEFAULT_DRAG_DELAY;\n\n      case false:\n        return 0;\n\n      default:\n        return value;\n    }\n  }\n});\n\nfunction getInternalGenericOptions(config) {\n  if (config === void 0) {\n    config = {};\n  } // TODO warn when passive is set to true and domTarget is undefined\n\n\n  return resolveWith(config, InternalGenericOptionsNormalizers);\n}\n\nfunction getInternalCoordinatesOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalCoordinatesOptionsNormalizers);\n}\n\nfunction getInternalDistanceAngleOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalDistanceAngleOptionsNormalizers);\n}\n\nfunction getInternalDragOptions(config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  return resolveWith(config, InternalDragOptionsNormalizers);\n}\n\nfunction _buildMoveConfig(_ref) {\n  var domTarget = _ref.domTarget,\n      eventOptions = _ref.eventOptions,\n      window = _ref.window,\n      enabled = _ref.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.move = getInternalCoordinatesOptions(rest);\n  return opts;\n}\n\nfunction _buildHoverConfig(_ref2) {\n  var domTarget = _ref2.domTarget,\n      eventOptions = _ref2.eventOptions,\n      window = _ref2.window,\n      enabled = _ref2.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref2, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.hover = _extends({\n    enabled: true\n  }, rest);\n  return opts;\n}\n\nfunction _buildDragConfig(_ref3) {\n  var domTarget = _ref3.domTarget,\n      eventOptions = _ref3.eventOptions,\n      window = _ref3.window,\n      enabled = _ref3.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref3, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.drag = getInternalDragOptions(rest);\n  return opts;\n}\n\nfunction _buildPinchConfig(_ref4) {\n  var domTarget = _ref4.domTarget,\n      eventOptions = _ref4.eventOptions,\n      window = _ref4.window,\n      enabled = _ref4.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref4, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.pinch = getInternalDistanceAngleOptions(rest);\n  return opts;\n}\n\nfunction _buildScrollConfig(_ref5) {\n  var domTarget = _ref5.domTarget,\n      eventOptions = _ref5.eventOptions,\n      window = _ref5.window,\n      enabled = _ref5.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref5, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.scroll = getInternalCoordinatesOptions(rest);\n  return opts;\n}\n\nfunction _buildWheelConfig(_ref6) {\n  var domTarget = _ref6.domTarget,\n      eventOptions = _ref6.eventOptions,\n      window = _ref6.window,\n      enabled = _ref6.enabled,\n      rest = _objectWithoutPropertiesLoose(_ref6, [\"domTarget\", \"eventOptions\", \"window\", \"enabled\"]);\n\n  var opts = getInternalGenericOptions({\n    domTarget: domTarget,\n    eventOptions: eventOptions,\n    window: window,\n    enabled: enabled\n  });\n  opts.wheel = getInternalCoordinatesOptions(rest);\n  return opts;\n}\n\nfunction buildComplexConfig(config, actions) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  if (actions === void 0) {\n    actions = new Set();\n  }\n\n  var _config = config,\n      drag = _config.drag,\n      wheel = _config.wheel,\n      move = _config.move,\n      scroll = _config.scroll,\n      pinch = _config.pinch,\n      hover = _config.hover,\n      eventOptions = _config.eventOptions,\n      window = _config.window,\n      domTarget = _config.domTarget,\n      enabled = _config.enabled;\n  var mergedConfig = getInternalGenericOptions({\n    eventOptions: eventOptions,\n    window: window,\n    domTarget: domTarget,\n    enabled: enabled\n  });\n  if (actions.has('onDrag')) mergedConfig.drag = getInternalDragOptions(drag);\n  if (actions.has('onWheel')) mergedConfig.wheel = getInternalCoordinatesOptions(wheel);\n  if (actions.has('onScroll')) mergedConfig.scroll = getInternalCoordinatesOptions(scroll);\n  if (actions.has('onMove')) mergedConfig.move = getInternalCoordinatesOptions(move);\n  if (actions.has('onPinch')) mergedConfig.pinch = getInternalDistanceAngleOptions(pinch);\n  if (actions.has('onHover')) mergedConfig.hover = _extends({\n    enabled: true\n  }, hover);\n  return mergedConfig;\n}\n\nfunction getInitial(mixed) {\n  return _extends({\n    _active: false,\n    _blocked: false,\n    _intentional: [false, false],\n    _movement: [0, 0],\n    _initial: [0, 0],\n    _bounds: [[-Infinity, Infinity], [-Infinity, Infinity]],\n    _lastEventType: undefined,\n    event: undefined,\n    // currentTarget: undefined,\n    // pointerId: undefined,\n    intentional: false,\n    values: [0, 0],\n    velocities: [0, 0],\n    delta: [0, 0],\n    movement: [0, 0],\n    offset: [0, 0],\n    lastOffset: [0, 0],\n    direction: [0, 0],\n    initial: [0, 0],\n    previous: [0, 0],\n    first: false,\n    last: false,\n    active: false,\n    timeStamp: 0,\n    startTime: 0,\n    elapsedTime: 0,\n    cancel: noop,\n    canceled: false,\n    memo: undefined,\n    args: undefined\n  }, mixed);\n}\n\nfunction getInitialState() {\n  var shared = {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false\n  };\n  var drag = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0,\n    _isTap: true,\n    _delayedEvent: false,\n    _pointerId: undefined,\n    tap: false,\n    swipe: [0, 0]\n  });\n  var pinch = getInitial({\n    da: [0, 0],\n    vdva: [0, 0],\n    // @ts-ignore origin can never be passed as undefined in userland\n    origin: undefined,\n    turns: 0\n  });\n  var wheel = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var move = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  var scroll = getInitial({\n    axis: undefined,\n    xy: [0, 0],\n    vxvy: [0, 0],\n    velocity: 0,\n    distance: 0\n  });\n  return {\n    shared: shared,\n    drag: drag,\n    pinch: pinch,\n    wheel: wheel,\n    move: move,\n    scroll: scroll\n  };\n}\n\nvar RecognizersMap = /*#__PURE__*/new Map();\n/**\r\n * @private\r\n * Recognizer abstract class.\r\n */\n\nvar Recognizer = /*#__PURE__*/function () {\n  /**\r\n   * Creates an instance of a gesture recognizer.\r\n   * @param stateKey drag, move, pinch, etc.\r\n   * @param controller the controller attached to the gesture\r\n   * @param [args] the args that should be passed to the gesture handler\r\n   */\n  function Recognizer(controller, args) {\n    var _this = this;\n\n    if (args === void 0) {\n      args = [];\n    }\n\n    this.controller = controller;\n    this.args = args;\n    this.debounced = true; // Convenience method to set a timeout for a given gesture\n\n    this.setTimeout = function (callback, ms) {\n      var _window;\n\n      if (ms === void 0) {\n        ms = 140;\n      }\n\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n    }; // Convenience method to clear a timeout for a given gesture\n\n\n    this.clearTimeout = function () {\n      clearTimeout(_this.controller.timeouts[_this.stateKey]);\n    };\n    /**\r\n     * Fires the gesture handler\r\n     */\n\n\n    this.fireGestureHandler = function (forceFlag) {\n      if (forceFlag === void 0) {\n        forceFlag = false;\n      }\n      /**\r\n       * If the gesture has been blocked (this can happen when the gesture has started in an unwanted direction),\r\n       * clean everything and don't do anything.\r\n       */\n\n\n      if (_this.state._blocked) {\n        // we need debounced gestures to end by themselves\n        if (!_this.debounced) {\n          _this.state._active = false;\n\n          _this.clean();\n        }\n\n        return null;\n      } // If the gesture has no intentional dimension, don't fire the handler.\n\n\n      if (!forceFlag && !_this.state.intentional && !_this.config.triggerAllEvents) return null;\n\n      if (_this.state.intentional) {\n        var prev_active = _this.state.active;\n        var next_active = _this.state._active;\n        _this.state.active = next_active;\n        _this.state.first = next_active && !prev_active;\n        _this.state.last = prev_active && !next_active;\n        _this.controller.state.shared[_this.ingKey] = next_active; // Sets dragging, pinching, etc. to the gesture active state\n      }\n\n      var state = _extends({}, _this.controller.state.shared, _this.state, _this.mapStateValues(_this.state)); // @ts-ignore\n\n\n      var newMemo = _this.handler(state); // Sets memo to the returned value of the handler (unless it's not undefined)\n\n\n      _this.state.memo = newMemo !== void 0 ? newMemo : _this.state.memo; // Cleans the gesture when the gesture is no longer active.\n\n      if (!_this.state._active) _this.clean();\n      return state;\n    };\n  } // Returns the gesture config\n\n\n  var _proto = Recognizer.prototype; // Convenience method to update the shared state\n\n  _proto.updateSharedState = function updateSharedState(sharedState) {\n    Object.assign(this.controller.state.shared, sharedState);\n  } // Convenience method to update the gesture state\n  ;\n\n  _proto.updateGestureState = function updateGestureState(gestureState) {\n    Object.assign(this.state, gestureState);\n  }\n  /**\r\n   * Returns state properties depending on the movement and state.\r\n   *\r\n   * Should be overriden for custom behavior, doesn't do anything in the implementation\r\n   * below.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    return {\n      _intentional: _intentional,\n      _blocked: false\n    };\n  }\n  /**\r\n   * Returns basic movement properties for the gesture based on the next values and current state.\r\n   */\n  ;\n\n  _proto.getMovement = function getMovement(values) {\n    var _this$config = this.config,\n        initial = _this$config.initial,\n        bounds = _this$config.bounds,\n        rubberband = _this$config.rubberband,\n        T = _this$config.threshold;\n    var _this$state = this.state,\n        _bounds = _this$state._bounds,\n        _initial = _this$state._initial,\n        _active = _this$state._active,\n        wasIntentional = _this$state._intentional,\n        lastOffset = _this$state.lastOffset,\n        prevMovement = _this$state.movement;\n    var M = this.getInternalMovement(values, this.state);\n    var i0 = wasIntentional[0] === false ? getIntentionalDisplacement(M[0], T[0]) : wasIntentional[0];\n    var i1 = wasIntentional[1] === false ? getIntentionalDisplacement(M[1], T[1]) : wasIntentional[1]; // Get gesture specific state properties based on intentionality and movement.\n\n    var intentionalityCheck = this.checkIntentionality([i0, i1], M);\n\n    if (intentionalityCheck._blocked) {\n      return _extends({}, intentionalityCheck, {\n        _movement: M,\n        delta: [0, 0]\n      });\n    }\n\n    var _intentional = intentionalityCheck._intentional;\n    var _movement = M;\n\n    var __cachedBounds;\n\n    var __cachedInitial;\n\n    if (_intentional[0] !== false && wasIntentional[0] === false) {\n      __cachedInitial = valueFn(initial, this.state);\n      __cachedBounds = valueFn(bounds, this.state);\n      _initial[0] = __cachedInitial[0];\n      _bounds[0] = __cachedBounds[0];\n    }\n\n    if (_intentional[1] !== false && wasIntentional[1] === false) {\n      var _cachedInitial, _cachedBounds;\n\n      __cachedInitial = (_cachedInitial = __cachedInitial) != null ? _cachedInitial : valueFn(initial, this.state);\n      __cachedBounds = (_cachedBounds = __cachedBounds) != null ? _cachedBounds : valueFn(bounds, this.state);\n      _initial[1] = __cachedInitial[1];\n      _bounds[1] = __cachedBounds[1];\n    }\n    /**\r\n     * The movement sent to the handler has 0 in its dimensions when intentionality is false.\r\n     * It is calculated from the actual movement minus the threshold.\r\n     */\n\n\n    var movement = [_intentional[0] !== false ? M[0] - _intentional[0] : _initial[0], _intentional[1] !== false ? M[1] - _intentional[1] : _initial[1]];\n    var offset = addV(movement, lastOffset);\n    /**\r\n     * Rubberband should be 0 when the gesture is no longer active, so that movement\r\n     * and offset can return within their bounds.\r\n     */\n\n    var _rubberband = _active ? rubberband : [0, 0];\n\n    movement = computeRubberband(_bounds, addV(movement, _initial), _rubberband);\n    return _extends({}, intentionalityCheck, {\n      intentional: _intentional[0] !== false || _intentional[1] !== false,\n      _initial: _initial,\n      _movement: _movement,\n      movement: movement,\n      values: values,\n      offset: computeRubberband(_bounds, offset, _rubberband),\n      delta: subV(movement, prevMovement)\n    });\n  } // Cleans the gesture. Can be overriden by gestures.\n  ;\n\n  _proto.clean = function clean() {\n    this.clearTimeout();\n  };\n\n  _createClass(Recognizer, [{\n    key: \"config\",\n    get: function get() {\n      return this.controller.config[this.stateKey];\n    } // Is the gesture enabled\n\n  }, {\n    key: \"enabled\",\n    get: function get() {\n      return this.controller.config.enabled && this.config.enabled;\n    } // Returns the controller state for a given gesture\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this.controller.state[this.stateKey];\n    } // Returns the gesture handler\n\n  }, {\n    key: \"handler\",\n    get: function get() {\n      return this.controller.handlers[this.stateKey];\n    }\n  }]);\n\n  return Recognizer;\n}(); //--------------------------------------------\n\n\nfunction getIntentionalDisplacement(movement, threshold) {\n  if (Math.abs(movement) >= threshold) {\n    return sign(movement) * threshold;\n  } else {\n    return false;\n  }\n}\n\nfunction computeRubberband(bounds, _ref, _ref2) {\n  var Vx = _ref[0],\n      Vy = _ref[1];\n  var Rx = _ref2[0],\n      Ry = _ref2[1];\n  var _bounds$ = bounds[0],\n      X1 = _bounds$[0],\n      X2 = _bounds$[1],\n      _bounds$2 = bounds[1],\n      Y1 = _bounds$2[0],\n      Y2 = _bounds$2[1];\n  return [rubberbandIfOutOfBounds(Vx, X1, X2, Rx), rubberbandIfOutOfBounds(Vy, Y1, Y2, Ry)];\n}\n/**\r\n * Returns a generic, common payload for all gestures from an event.\r\n */\n\n\nfunction getGenericPayload(_ref3, event, isStartEvent) {\n  var state = _ref3.state,\n      args = _ref3.args;\n  var timeStamp = event.timeStamp,\n      _lastEventType = event.type;\n  var previous = state.values;\n  var elapsedTime = isStartEvent ? 0 : timeStamp - state.startTime;\n  return {\n    _lastEventType: _lastEventType,\n    event: event,\n    timeStamp: timeStamp,\n    elapsedTime: elapsedTime,\n    args: args,\n    previous: previous\n  };\n}\n/**\r\n * Returns the reinitialized start state for the gesture.\r\n * Should be common to all gestures.\r\n */\n\n\nfunction getStartGestureState(recognizer, values, event) {\n  var offset = recognizer.state.offset;\n  var startTime = event.timeStamp;\n  return _extends({}, getInitialState()[recognizer.stateKey], {\n    _active: true,\n    values: values,\n    initial: values,\n    offset: offset,\n    lastOffset: offset,\n    startTime: startTime\n  });\n}\n\nfunction partial(func, state) {\n  return function (event) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    } // @ts-ignore\n\n\n    return func.call.apply(func, [this, _extends({}, state, {\n      event: event\n    })].concat(args));\n  };\n}\n/**\r\n * The controller will keep track of the state for all gestures and also keep\r\n * track of timeouts, and window listeners.\r\n */\n\n\nvar Controller = function Controller(classes) {\n  var _this = this;\n\n  this.classes = classes;\n\n  this.bind = function () {\n    var bindings = {};\n\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    for (var _iterator = _createForOfIteratorHelperLoose(_this.classes), _step; !(_step = _iterator()).done;) {\n      var RecognizerClass = _step.value;\n      new RecognizerClass(_this, args).addBindings(bindings);\n    } // we also add event bindings for native handlers\n\n\n    for (var _i = 0, _Object$entries = Object.entries(_this.nativeRefs); _i < _Object$entries.length; _i++) {\n      var _Object$entries$_i = _Object$entries[_i],\n          event = _Object$entries$_i[0],\n          handler = _Object$entries$_i[1];\n      addBindings(bindings, event, partial(handler, _extends({}, _this.state.shared, {\n        args: args\n      })));\n    }\n\n    if (_this.config.domTarget) {\n      // If config.domTarget is set we add event listeners to it and return the clean function.\n      return updateDomListeners(_this, bindings);\n    } else {\n      // If not, we return an object that contains gesture handlers mapped to react handler event keys.\n      return getPropsListener(_this, bindings);\n    }\n  };\n\n  this.effect = function () {\n    if (_this.config.domTarget) _this.bind();\n    return _this.clean;\n  };\n  /**\r\n   * Function ran on component unmount: cleans timeouts and removes dom listeners set by the bind function.\r\n   */\n\n\n  this.clean = function () {\n    var domTarget = getDomTargetFromConfig(_this.config);\n    var eventOptions = _this.config.eventOptions;\n    if (domTarget) removeListeners(domTarget, takeAll(_this.domListeners), eventOptions);\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    clearAllWindowListeners(_this);\n  };\n\n  this.state = getInitialState();\n  this.timeouts = {};\n  this.domListeners = [];\n  this.windowListeners = {};\n};\n\nfunction clearAllWindowListeners(controller) {\n  var _controller$config = controller.config,\n      el = _controller$config.window,\n      eventOptions = _controller$config.eventOptions,\n      windowListeners = controller.windowListeners;\n  if (!el) return;\n\n  for (var stateKey in windowListeners) {\n    var handlers = windowListeners[stateKey];\n    removeListeners(el, handlers, eventOptions);\n  }\n\n  controller.windowListeners = {};\n}\n\nfunction clearWindowListeners(_ref, stateKey) {\n  var config = _ref.config,\n      windowListeners = _ref.windowListeners;\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], config.eventOptions);\n  delete windowListeners[stateKey];\n}\n\nfunction updateWindowListeners(_ref2, stateKey, listeners) {\n  var config = _ref2.config,\n      windowListeners = _ref2.windowListeners;\n\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (!config.window) return;\n  removeListeners(config.window, windowListeners[stateKey], config.eventOptions);\n  addListeners(config.window, windowListeners[stateKey] = listeners, config.eventOptions);\n}\n\nfunction updateDomListeners(_ref3, bindings) {\n  var config = _ref3.config,\n      domListeners = _ref3.domListeners;\n  var domTarget = getDomTargetFromConfig(config);\n  if (!domTarget) throw new Error('domTarget must be defined');\n  var eventOptions = config.eventOptions;\n  removeListeners(domTarget, takeAll(domListeners), eventOptions);\n\n  for (var _i2 = 0, _Object$entries2 = Object.entries(bindings); _i2 < _Object$entries2.length; _i2++) {\n    var _Object$entries2$_i = _Object$entries2[_i2],\n        key = _Object$entries2$_i[0],\n        fns = _Object$entries2$_i[1];\n    var name = key.slice(2).toLowerCase();\n    domListeners.push([name, chainFns.apply(void 0, fns)]);\n  }\n\n  addListeners(domTarget, domListeners, eventOptions);\n}\n\nfunction getPropsListener(_ref4, bindings) {\n  var config = _ref4.config;\n  var props = {};\n  var captureString = config.eventOptions.capture ? 'Capture' : '';\n\n  for (var _i3 = 0, _Object$entries3 = Object.entries(bindings); _i3 < _Object$entries3.length; _i3++) {\n    var _Object$entries3$_i = _Object$entries3[_i3],\n        event = _Object$entries3$_i[0],\n        fns = _Object$entries3$_i[1];\n    var fnsArray = Array.isArray(fns) ? fns : [fns];\n    var key = event + captureString;\n    props[key] = chainFns.apply(void 0, fnsArray);\n  }\n\n  return props;\n}\n\nfunction takeAll(array) {\n  if (array === void 0) {\n    array = [];\n  }\n\n  return array.splice(0, array.length);\n}\n\nfunction getDomTargetFromConfig(_ref5) {\n  var domTarget = _ref5.domTarget;\n  return domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n}\n/**\r\n * bindings is an object which keys match ReactEventHandlerKeys.\r\n * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n * that key.\r\n */\n\n\nfunction addBindings(bindings, name, fn) {\n  if (!bindings[name]) bindings[name] = [];\n  bindings[name].push(fn);\n}\n\nfunction addListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _iterator2 = _createForOfIteratorHelperLoose(listeners), _step2; !(_step2 = _iterator2()).done;) {\n    var _step2$value = _step2.value,\n        eventName = _step2$value[0],\n        eventHandler = _step2$value[1];\n    el.addEventListener(eventName, eventHandler, options);\n  }\n}\n\nfunction removeListeners(el, listeners, options) {\n  if (listeners === void 0) {\n    listeners = [];\n  }\n\n  if (options === void 0) {\n    options = {};\n  }\n\n  for (var _iterator3 = _createForOfIteratorHelperLoose(listeners), _step3; !(_step3 = _iterator3()).done;) {\n    var _step3$value = _step3.value,\n        eventName = _step3$value[0],\n        eventHandler = _step3$value[1];\n    el.removeEventListener(eventName, eventHandler, options);\n  }\n}\n/* eslint-disable react-hooks/exhaustive-deps */\n\n/**\r\n * Utility hook called by all gesture hooks and that will be responsible for the internals.\r\n *\r\n * @param handlers\r\n * @param classes\r\n * @param config\r\n * @param nativeHandlers - native handlers such as onClick, onMouseDown, etc.\r\n */\n\n\nfunction useRecognizers(handlers, config, nativeHandlers) {\n  if (nativeHandlers === void 0) {\n    nativeHandlers = {};\n  }\n\n  var classes = resolveClasses(handlers);\n  var controller = React.useMemo(function () {\n    return new Controller(classes);\n  }, []);\n  controller.config = config;\n  controller.handlers = handlers;\n  controller.nativeRefs = nativeHandlers;\n  React.useEffect(controller.effect, []); // @ts-ignore\n\n  if (controller.config.domTarget) return deprecationNoticeForDomTarget; // @ts-ignore\n\n  return controller.bind;\n}\n\nfunction deprecationNoticeForDomTarget() {\n  if (process.env.NODE_ENV === 'development') {\n    console.warn(\"Deprecation notice: When the `domTarget` option is specified, you don't need to write `useEffect(bind, [bind])` anymore: event binding is now made handled internally to this lib.\\n\\nNext version won't return anything when `domTarget` is provided, therefore your code will break if you try to call `useEffect`.\");\n  }\n}\n\nfunction resolveClasses(internalHandlers) {\n  var classes = new Set();\n  if (internalHandlers.drag) classes.add(RecognizersMap.get('drag'));\n  if (internalHandlers.wheel) classes.add(RecognizersMap.get('wheel'));\n  if (internalHandlers.scroll) classes.add(RecognizersMap.get('scroll'));\n  if (internalHandlers.move) classes.add(RecognizersMap.get('move'));\n  if (internalHandlers.pinch) classes.add(RecognizersMap.get('pinch'));\n  if (internalHandlers.hover) classes.add(RecognizersMap.get('hover'));\n  return classes;\n}\n/**\r\n * @private\r\n * Abstract class for coordinates-based gesture recongizers\r\n */\n\n\nvar CoordinatesRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n\n  function CoordinatesRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = CoordinatesRecognizer.prototype;\n  /**\r\n   * Returns the real movement (without taking intentionality into acount)\r\n   */\n\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    return subV(values, state.initial);\n  }\n  /**\r\n   * In coordinates-based gesture, this function will detect the first intentional axis,\r\n   * lock the gesture axis if lockDirection is specified in the config, block the gesture\r\n   * if the first intentional axis doesn't match the specified axis in config.\r\n   */\n  ;\n\n  _proto.checkIntentionality = function checkIntentionality(_intentional, _movement) {\n    if (_intentional[0] === false && _intentional[1] === false) {\n      return {\n        _intentional: _intentional,\n        axis: this.state.axis\n      };\n    }\n\n    var _movement$map = _movement.map(Math.abs),\n        absX = _movement$map[0],\n        absY = _movement$map[1];\n\n    var axis = this.state.axis || (absX > absY ? 'x' : absX < absY ? 'y' : undefined);\n    if (!this.config.axis && !this.config.lockDirection) return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n    if (!axis) return {\n      _intentional: [false, false],\n      _blocked: false,\n      axis: axis\n    };\n    if (!!this.config.axis && axis !== this.config.axis) return {\n      _intentional: _intentional,\n      _blocked: true,\n      axis: axis\n    };\n    _intentional[axis === 'x' ? 1 : 0] = false;\n    return {\n      _intentional: _intentional,\n      _blocked: false,\n      axis: axis\n    };\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n\n    if (!state._blocked) {\n      var dt = event.timeStamp - this.state.timeStamp;\n      Object.assign(state, calculateAllKinematics(state.movement, state.delta, dt));\n    }\n\n    return state;\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      xy: state.values,\n      vxvy: state.velocities\n    };\n  };\n\n  return CoordinatesRecognizer;\n}(Recognizer);\n\nvar WEBKIT_DISTANCE_SCALE_FACTOR = 260;\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\nfunction supportsGestureEvents() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: no type definitions for webkit GestureEvents\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction supportsTouchEvents() {\n  return typeof window !== 'undefined' && window.ontouchstart === null;\n}\n\nfunction getTouchEvents(event) {\n  if ('touches' in event) {\n    var targetTouches = event.targetTouches,\n        changedTouches = event.changedTouches;\n    return targetTouches.length > 0 ? targetTouches : changedTouches;\n  }\n\n  return null;\n}\n\nfunction getGenericEventData(event) {\n  var buttons = 'buttons' in event ? event.buttons : 0;\n  var touchEvents = getTouchEvents(event);\n  var touches = touchEvents && touchEvents.length || 0;\n  var down = touches > 0 || buttons > 0;\n  var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey; // TODO check if this might create some overrides?\n\n  return {\n    touches: touches,\n    down: down,\n    buttons: buttons,\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n/**\r\n * Gets pointer event values.\r\n * @param event\r\n * @returns pointer event values\r\n */\n\n\nfunction getPointerEventValues(event) {\n  var touchEvents = getTouchEvents(event);\n\n  var _ref = touchEvents ? touchEvents[0] : event,\n      clientX = _ref.clientX,\n      clientY = _ref.clientY;\n\n  return [clientX, clientY];\n}\n/**\r\n * Gets scroll event values\r\n * @param event\r\n * @returns scroll event values\r\n */\n\n\nfunction getScrollEventValues(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n      scrollX = _event$currentTarget.scrollX,\n      scrollY = _event$currentTarget.scrollY,\n      scrollLeft = _event$currentTarget.scrollLeft,\n      scrollTop = _event$currentTarget.scrollTop;\n  return [scrollX || scrollLeft || 0, scrollY || scrollTop || 0];\n}\n/**\r\n * Gets wheel event values.\r\n * @param event\r\n * @returns wheel event values\r\n */\n\n\nfunction getWheelEventValues(event) {\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return [deltaX, deltaY];\n}\n/**\r\n * Gets webkit gesture event values.\r\n * @param event\r\n * @returns webkit gesture event values\r\n */\n\n\nfunction getWebkitGestureEventValues(event) {\n  return [event.scale * WEBKIT_DISTANCE_SCALE_FACTOR, event.rotation];\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\n\nfunction getTwoTouchesEventData(event) {\n  var _e$rotation;\n\n  var targetTouches = event.targetTouches;\n  var A = targetTouches[0],\n      B = targetTouches[1];\n  var dx = B.clientX - A.clientX;\n  var dy = B.clientY - A.clientY;\n  var cx = (B.clientX + A.clientX) / 2;\n  var cy = (B.clientY + A.clientY) / 2;\n  var e = 'nativeEvent' in event ? event.nativeEvent : event;\n  var distance = Math.hypot(dx, dy);\n  var angle = (_e$rotation = e.rotation) != null ? _e$rotation : -(Math.atan2(dx, dy) * 180) / Math.PI;\n  var values = [distance, angle];\n  var origin = [cx, cy];\n  return {\n    values: values,\n    origin: origin\n  };\n}\n\nvar TAP_DISTANCE_THRESHOLD = 3;\nvar SWIPE_MAX_ELAPSED_TIME = 220;\n\nvar DragRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n\n  function DragRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'dragging';\n    _this.stateKey = 'drag';\n    /**\r\n     * TODO add back when setPointerCapture is widely wupported\r\n     * https://caniuse.com/#search=setPointerCapture\r\n     * private setPointers = (event: UseGestureEvent<PointerEvent>) => {\r\n     *   const { currentTarget, pointerId } = event\r\n     *   if (currentTarget) currentTarget.setPointerCapture(pointerId)\r\n     *   this.updateGestureState({ currentTarget, pointerId })\r\n     * }\r\n            * private removePointers = () => {\r\n     *   const { currentTarget, pointerId } = this.state\r\n     *   if (currentTarget && pointerId) currentTarget.releasePointerCapture(pointerId)\r\n     * }\r\n     */\n\n    _this.onDragStart = function (event) {\n      if (!_this.enabled || _this.state._active) return;\n      /**\r\n       * TODO add back when setPointerCapture is widely supported\r\n       * this.setPointers(event as PointerEvent)\r\n       */\n\n      updateWindowListeners(_this.controller, _this.stateKey, [['pointermove', _this.onDragChange], ['pointerup', _this.onDragEnd], ['pointercancel', _this.onDragEnd]]); // We set the state pointerId to the event.pointerId so we can make sure\n      // that we lock the drag to the event initiating the gesture\n\n      _this.updateGestureState({\n        _pointerId: event.pointerId\n      });\n\n      if (_this.config.delay > 0) {\n        _this.state._delayedEvent = true; // If it's a React SyntheticEvent we need to persist it so that we can use it async\n\n        if ('persist' in event && typeof event.persist === 'function') event.persist();\n\n        _this.setTimeout(_this.startDrag.bind(_assertThisInitialized(_this)), _this.config.delay, event);\n      } else {\n        _this.startDrag(event);\n      }\n    };\n\n    _this.onDragChange = function (event) {\n      // If the gesture was canceled don't respond to the event.\n      if (_this.state.canceled) return; // If the event pointerId doesn't match the initiating pointerId\n      // don't respond to the event.\n\n      if (event.pointerId !== _this.state._pointerId) return; // If the gesture isn't active then respond to the event only if\n      // it's been delayed via the `delay` option, in which case start\n      // the gesture immediately.\n\n      if (!_this.state._active) {\n        if (_this.state._delayedEvent) {\n          _this.clearTimeout();\n\n          _this.startDrag(event);\n        }\n\n        return;\n      }\n\n      var genericEventData = getGenericEventData(event); // If the event doesn't have any button / touches left we should cancel\n      // the gesture. This may happen if the drag release happens outside the browser\n      // window.\n\n      if (!genericEventData.down) {\n        _this.onDragEnd(event);\n\n        return;\n      }\n\n      _this.updateSharedState(genericEventData);\n\n      var values = getPointerEventValues(event);\n\n      var kinematics = _this.getKinematics(values, event);\n\n      var genericPayload = getGenericPayload(_assertThisInitialized(_this), event); // This verifies if the drag can be assimilated to a tap by checking\n      // if the real distance of the drag (ie not accounting for the threshold) is\n      // greater than the TAP_DISTANCE_THRESHOLD.\n\n      var _isTap = _this.state._isTap;\n      var realDistance = calculateDistance(kinematics._movement);\n      if (_isTap && realDistance >= TAP_DISTANCE_THRESHOLD) _isTap = false;\n\n      _this.updateGestureState(_extends({}, genericPayload, kinematics, {\n        _isTap: _isTap\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onDragEnd = function (event) {\n      // If the event pointerId doesn't match the initiating pointerId\n      // don't respond to the event.\n      if (event.pointerId !== _this.state._pointerId) return;\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n\n      var tap = _this.state._isTap;\n      var _this$state$velocitie = _this.state.velocities,\n          vx = _this$state$velocitie[0],\n          vy = _this$state$velocitie[1];\n      var _this$state$movement = _this.state.movement,\n          mx = _this$state$movement[0],\n          my = _this$state$movement[1];\n      var _this$state$_intentio = _this.state._intentional,\n          ix = _this$state$_intentio[0],\n          iy = _this$state$_intentio[1];\n      var _this$config$swipeVel = _this.config.swipeVelocity,\n          svx = _this$config$swipeVel[0],\n          svy = _this$config$swipeVel[1];\n      var _this$config$swipeDis = _this.config.swipeDistance,\n          sx = _this$config$swipeDis[0],\n          sy = _this$config$swipeDis[1];\n\n      var endState = _extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values));\n\n      var swipe = [0, 0];\n\n      if (endState.elapsedTime < SWIPE_MAX_ELAPSED_TIME) {\n        if (ix !== false && Math.abs(vx) > svx && Math.abs(mx) > sx) swipe[0] = sign(vx);\n        if (iy !== false && Math.abs(vy) > svy && Math.abs(my) > sy) swipe[1] = sign(vy);\n      }\n\n      _this.updateGestureState(_extends({}, endState, {\n        tap: tap,\n        swipe: swipe\n      }));\n\n      _this.fireGestureHandler(tap === true);\n    };\n\n    _this.clean = function () {\n      _CoordinatesRecognize.prototype.clean.call(_assertThisInitialized(_this));\n\n      _this.state._delayedEvent = false; // can't remember if this is useful?\n\n      clearWindowListeners(_this.controller, _this.stateKey); // TODO add back when setPointerCapture is widely wupported\n      // this.removePointers()\n    };\n\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n\n      _this.updateGestureState({\n        canceled: true\n      });\n\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        buttons: 0,\n        touches: 0\n      });\n\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n\n    _this.onClick = function (event) {\n      if (!_this.state._isTap) event.stopPropagation();\n    };\n\n    return _this;\n  }\n\n  var _proto = DragRecognizer.prototype;\n\n  _proto.startDrag = function startDrag(event) {\n    var values = getPointerEventValues(event);\n    this.updateSharedState(getGenericEventData(event));\n    this.updateGestureState(_extends({}, getStartGestureState(this, values, event), getGenericPayload(this, event, true), {\n      _pointerId: event.pointerId,\n      cancel: this.onCancel\n    }));\n    this.updateGestureState(this.getMovement(values));\n    this.fireGestureHandler();\n  };\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onPointerDown', this.onDragStart);\n\n    if (this.config.filterTaps) {\n      var handler = this.controller.config.eventOptions.capture ? 'onClick' : 'onClickCapture';\n      addBindings(bindings, handler, this.onClick);\n    } // TODO add back when setPointerCapture is widely wupported\n    // addBindings(bindings, 'onPointerMove', this.onDragChange)\n    // addBindings(bindings, 'onPointerUp', this.onDragEnd)\n    // addBindings(bindings, 'onPointerCancel', this.onDragEnd)\n\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Inlined from https://github.com/alexreardon/memoize-one\r\n */\n\n\nfunction memoizeOne(resultFn, isEqual) {\n  var lastThis;\n  var lastArgs = [];\n  var lastResult;\n  var calledOnce = false;\n\n  function memoized() {\n    for (var _len = arguments.length, newArgs = new Array(_len), _key = 0; _key < _len; _key++) {\n      newArgs[_key] = arguments[_key];\n    }\n\n    if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n      return lastResult;\n    }\n\n    lastResult = resultFn.apply(this, newArgs);\n    calledOnce = true;\n    lastThis = this;\n    lastArgs = newArgs;\n    return lastResult;\n  }\n\n  return memoized;\n}\n/**\r\n * Taken from https://github.com/FormidableLabs/react-fast-compare\r\n *\r\n * Dropped comments and ArrayBuffer handling\r\n */\n\n\nfunction equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n    var length, i, keys;\n\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n\n      for (i = length; i-- !== 0;) {\n        if (!equal(a[i], b[i])) return false;\n      }\n\n      return true;\n    }\n\n    var it;\n\n    if (typeof Map === 'function' && a instanceof Map && b instanceof Map) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!equal(i.value[1], b.get(i.value[0]))) return false;\n      }\n\n      return true;\n    }\n\n    if (typeof Set === 'function' && a instanceof Set && b instanceof Set) {\n      if (a.size !== b.size) return false;\n      it = a.entries();\n\n      while (!(i = it.next()).done) {\n        if (!b.has(i.value[0])) return false;\n      }\n\n      return true;\n    }\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n    }\n\n    if (typeof Element !== 'undefined' && a instanceof Element) return false;\n\n    for (i = length; i-- !== 0;) {\n      if (keys[i] === '_owner' && a.$$typeof) continue;\n      if (!equal(a[keys[i]], b[keys[i]])) return false;\n    }\n\n    return true;\n  } // true if both NaN, false otherwise — NaN !== NaN → true\n  // eslint-disable-next-line no-self-compare\n\n\n  return a !== a && b !== b;\n}\n\nfunction isEqual(a, b) {\n  try {\n    return equal(a, b);\n  } catch (error) {\n    if ((error.message || '').match(/stack|recursion/i)) {\n      console.warn('react-fast-compare cannot handle circular refs');\n      return false;\n    }\n\n    throw error;\n  }\n}\n/**\r\n * Drag hook.\r\n *\r\n * @param handler - the function fired every time the drag gesture updates\r\n * @param [config={}] - the config object including generic options and drag options\r\n */\n\n\nfunction useDrag(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('drag', DragRecognizer);\n  var buildDragConfig = useRef();\n\n  if (!buildDragConfig.current) {\n    buildDragConfig.current = memoizeOne(_buildDragConfig, isEqual);\n  }\n\n  return useRecognizers({\n    drag: handler\n  }, buildDragConfig.current(config));\n}\n/**\r\n * @private\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */\n\n\nvar DistanceAngleRecognizer = /*#__PURE__*/function (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n\n  function DistanceAngleRecognizer() {\n    return _Recognizer.apply(this, arguments) || this;\n  }\n\n  var _proto = DistanceAngleRecognizer.prototype;\n\n  _proto.getInternalMovement = function getInternalMovement(values, state) {\n    var prev_a = state.values[1]; // not be defined if ctrl+wheel is used for zoom only\n\n    var d = values[0],\n        _values$ = values[1],\n        a = _values$ === void 0 ? prev_a : _values$;\n    var delta_a = a - prev_a;\n    var next_turns = state.turns;\n    if (Math.abs(delta_a) > 270) next_turns += sign(delta_a);\n    return subV([d, a - 360 * next_turns], state.initial);\n  };\n\n  _proto.getKinematics = function getKinematics(values, event) {\n    var state = this.getMovement(values);\n    var turns = (values[1] - state.movement[1] - this.state.initial[1]) / 360;\n    var dt = event.timeStamp - this.state.timeStamp;\n    var kinematics = calculateAllKinematics(state.movement, state.delta, dt);\n    return _extends({\n      turns: turns\n    }, state, kinematics);\n  };\n\n  _proto.mapStateValues = function mapStateValues(state) {\n    return {\n      da: state.values,\n      vdva: state.velocities\n    };\n  };\n\n  return DistanceAngleRecognizer;\n}(Recognizer);\n\nvar PinchRecognizer = /*#__PURE__*/function (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n\n  function PinchRecognizer() {\n    var _this;\n\n    _this = _DistanceAngleRecogni.apply(this, arguments) || this;\n    _this.ingKey = 'pinching';\n    _this.stateKey = 'pinch';\n\n    _this.pinchShouldStart = function (event) {\n      var _getGenericEventData = getGenericEventData(event),\n          touches = _getGenericEventData.touches;\n\n      return _this.enabled && touches === 2;\n    };\n\n    _this.onPinchStart = function (event) {\n      if (!_this.pinchShouldStart(event)) return;\n\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa.values,\n          origin = _getTwoTouchesEventDa.origin;\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        cancel: _this.onCancel,\n        origin: origin\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchChange = function (event) {\n      var _this$state = _this.state,\n          canceled = _this$state.canceled,\n          _active = _this$state._active;\n      if (canceled || !_active) return;\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa2.values,\n          origin = _getTwoTouchesEventDa2.origin; // @ts-ignore\n\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n        origin: origin\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPinchEnd = function (event) {\n      if (!_this.state.active) return;\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onCancel = function () {\n      if (_this.state.canceled) return;\n      _this.state._active = false;\n\n      _this.updateGestureState({\n        canceled: true\n      });\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      requestAnimationFrame(function () {\n        return _this.fireGestureHandler();\n      });\n    };\n    /**\r\n     * PINCH WITH WEBKIT GESTURES\r\n     */\n\n\n    _this.onGestureStart = function (event) {\n      if (!_this.enabled) return;\n      event.preventDefault(); // useless\n\n      var values = getWebkitGestureEventValues(event);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        origin: [event.clientX, event.clientY],\n        cancel: _this.onCancel\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureChange = function (event) {\n      var _this$state2 = _this.state,\n          canceled = _this$state2.canceled,\n          _active = _this$state2._active;\n      if (canceled || !_active) return;\n      event.preventDefault();\n      var genericEventData = getGenericEventData(event);\n\n      _this.updateSharedState(genericEventData);\n\n      var values = getWebkitGestureEventValues(event);\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), kinematics, {\n        origin: [event.clientX, event.clientY]\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onGestureEnd = function (event) {\n      event.preventDefault();\n      if (!_this.state.active) return;\n      _this.state._active = false;\n\n      _this.updateSharedState({\n        down: false,\n        touches: 0\n      });\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getMovement(_this.state.values), {\n        origin: [event.clientX, event.clientY]\n      }));\n\n      _this.fireGestureHandler();\n    };\n    /**\r\n     * PINCH WITH WHEEL\r\n     */\n\n\n    _this.wheelShouldRun = function (event) {\n      return _this.enabled && event.ctrlKey;\n    };\n\n    _this.getWheelValuesFromEvent = function (event) {\n      var _getWheelEventValues = getWheelEventValues(event),\n          delta_d = _getWheelEventValues[1];\n\n      var _this$state$values = _this.state.values,\n          prev_d = _this$state$values[0],\n          prev_a = _this$state$values[1];\n      var d = prev_d - delta_d;\n      var a = prev_a !== void 0 ? prev_a : 0;\n      return {\n        values: [d, a],\n        origin: [event.clientX, event.clientY],\n        delta: [0, delta_d]\n      };\n    };\n\n    _this.onWheel = function (event) {\n      if (!_this.wheelShouldRun(event)) return;\n\n      _this.setTimeout(_this.onWheelEnd);\n\n      if (!_this.state._active) _this.onWheelStart(event);else _this.onWheelChange(event);\n    };\n\n    _this.onWheelStart = function (event) {\n      var _this$getWheelValuesF = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF.values,\n          delta = _this$getWheelValuesF.delta,\n          origin = _this$getWheelValuesF.origin;\n\n      if (event.cancelable) event.preventDefault();else if (process.env.NODE_ENV === 'development') {\n        console.warn('To properly support zoom on trackpads, try using the `domTarget` option and `config.eventOptions.passive` set to `false`. This message will only appear in development mode.');\n      }\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n        initial: _this.state.values,\n        offset: values,\n        delta: delta,\n        origin: origin\n      }));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelChange = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n\n      var _this$getWheelValuesF2 = _this.getWheelValuesFromEvent(event),\n          values = _this$getWheelValuesF2.values,\n          origin = _this$getWheelValuesF2.origin,\n          delta = _this$getWheelValuesF2.delta;\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event), {\n        origin: origin,\n        delta: delta\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onWheelEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_this.getMovement(_this.state.values));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    // Only try to use gesture events when they are supported and domTarget is set\n    // as React doesn't support gesture handlers.\n    if (this.controller.config.domTarget && !supportsTouchEvents() && supportsGestureEvents()) {\n      addBindings(bindings, 'onGestureStart', this.onGestureStart);\n      addBindings(bindings, 'onGestureChange', this.onGestureChange);\n      addBindings(bindings, 'onGestureEnd', this.onGestureEnd);\n    } else {\n      addBindings(bindings, 'onTouchStart', this.onPinchStart);\n      addBindings(bindings, 'onTouchMove', this.onPinchChange);\n      addBindings(bindings, 'onTouchEnd', this.onPinchEnd);\n      addBindings(bindings, 'onTouchCancel', this.onPinchEnd);\n      addBindings(bindings, 'onWheel', this.onWheel);\n    }\n  };\n\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n/**\r\n * Pinch hook.\r\n *\r\n * @param handler - the function fired every time the pinch gesture updates\r\n * @param [config={}] - the config object including generic options and pinch options\r\n */\n\n\nfunction usePinch(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('pinch', PinchRecognizer);\n  var buildPinchConfig = useRef();\n\n  if (!buildPinchConfig.current) {\n    buildPinchConfig.current = memoizeOne(_buildPinchConfig, isEqual);\n  }\n\n  return useRecognizers({\n    pinch: handler\n  }, buildPinchConfig.current(config));\n}\n\nvar WheelRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n\n  function WheelRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'wheeling';\n    _this.stateKey = 'wheel';\n    _this.debounced = true;\n\n    _this.handleEvent = function (event) {\n      if (event.ctrlKey && 'pinch' in _this.controller.handlers) return;\n      if (!_this.enabled) return;\n\n      _this.setTimeout(_this.onEnd);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = addV(getWheelEventValues(event), _this.state.values);\n\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n          initial: _this.state.values\n        }));\n\n        var movement = _this.getMovement(values);\n\n        var geometry = calculateAllGeometry(movement.delta);\n\n        _this.updateGestureState(movement);\n\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onEnd = function () {\n      var movement = _this.getMovement(_this.state.values);\n\n      _this.updateGestureState(movement);\n\n      _this.updateGestureState({\n        _active: false,\n        velocities: [0, 0],\n        velocity: 0\n      });\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = WheelRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onWheel', this.handleEvent);\n  };\n\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Wheel hook.\r\n *\r\n * @param handler - the function fired every time the wheel gesture updates\r\n * @param the config object including generic options and wheel options\r\n */\n\n\nfunction useWheel(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var buildWheelConfig = useRef();\n\n  if (!buildWheelConfig.current) {\n    buildWheelConfig.current = memoizeOne(_buildWheelConfig, isEqual);\n  }\n\n  return useRecognizers({\n    wheel: handler\n  }, buildWheelConfig.current(config));\n}\n\nvar MoveRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n\n  function MoveRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'moving';\n    _this.stateKey = 'move';\n    _this.debounced = true;\n\n    _this.onMove = function (event) {\n      if (!_this.enabled) return;\n\n      _this.setTimeout(_this.onMoveEnd);\n\n      if (!_this.state._active) _this.onMoveStart(event);else _this.onMoveChange(event);\n    };\n\n    _this.onMoveStart = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = getPointerEventValues(event);\n\n      _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true)));\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveChange = function (event) {\n      _this.updateSharedState(getGenericEventData(event));\n\n      var values = getPointerEventValues(event);\n\n      _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onMoveEnd = function () {\n      var values = _this.state.values;\n\n      _this.updateGestureState(_this.getMovement(values));\n\n      _this.updateGestureState({\n        velocities: [0, 0],\n        velocity: 0,\n        _active: false\n      });\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onPointerEnter = function (event) {\n      _this.controller.state.shared.hovering = true;\n      if (!_this.controller.config.enabled) return;\n\n      if (_this.controller.config.hover.enabled) {\n        var values = getPointerEventValues(event);\n\n        var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event, true), {\n          values: values,\n          active: true,\n          hovering: true\n        });\n\n        _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n      }\n\n      if ('move' in _this.controller.handlers) _this.onMoveStart(event);\n    };\n\n    _this.onPointerLeave = function (event) {\n      _this.controller.state.shared.hovering = false;\n      if ('move' in _this.controller.handlers) _this.onMoveEnd();\n      if (!_this.controller.config.hover.enabled) return;\n      var values = getPointerEventValues(event);\n\n      var state = _extends({}, _this.controller.state.shared, _this.state, getGenericPayload(_assertThisInitialized(_this), event), {\n        values: values,\n        active: false\n      });\n\n      _this.controller.handlers.hover(_extends({}, state, _this.mapStateValues(state)));\n    };\n\n    return _this;\n  }\n\n  var _proto = MoveRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    if ('move' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerMove', this.onMove);\n    }\n\n    if ('hover' in this.controller.handlers) {\n      addBindings(bindings, 'onPointerEnter', this.onPointerEnter);\n      addBindings(bindings, 'onPointerLeave', this.onPointerLeave);\n    }\n  };\n\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Move hook.\r\n *\r\n * @param handler - the function fired every time the move gesture updates\r\n * @param [config={}] - the config object including generic options and move options\r\n */\n\n\nfunction useMove(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('move', MoveRecognizer);\n  var buildMoveConfig = useRef();\n\n  if (!buildMoveConfig.current) {\n    buildMoveConfig.current = memoizeOne(_buildMoveConfig, isEqual);\n  }\n\n  return useRecognizers({\n    move: handler\n  }, buildMoveConfig.current(config));\n}\n/**\r\n * Hover hook.\r\n *\r\n * @param handler - the function fired every time the hover gesture updates\r\n * @param [config={}] - the config object including generic options and hover options\r\n */\n\n\nfunction useHover(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('hover', MoveRecognizer);\n  var buildHoverConfig = useRef();\n\n  if (!buildHoverConfig.current) {\n    buildHoverConfig.current = memoizeOne(_buildHoverConfig, isEqual);\n  }\n\n  return useRecognizers({\n    hover: handler\n  }, buildHoverConfig.current(config));\n}\n\nvar ScrollRecognizer = /*#__PURE__*/function (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n\n  function ScrollRecognizer() {\n    var _this;\n\n    _this = _CoordinatesRecognize.apply(this, arguments) || this;\n    _this.ingKey = 'scrolling';\n    _this.stateKey = 'scroll';\n    _this.debounced = true;\n\n    _this.handleEvent = function (event) {\n      if (!_this.enabled) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var values = getScrollEventValues(event);\n\n      _this.updateSharedState(getGenericEventData(event));\n\n      if (!_this.state._active) {\n        _this.updateGestureState(_extends({}, getStartGestureState(_assertThisInitialized(_this), values, event), getGenericPayload(_assertThisInitialized(_this), event, true), {\n          initial: _this.state.values\n        }));\n\n        var movementDetection = _this.getMovement(values);\n\n        var geometry = calculateAllGeometry(movementDetection.delta);\n\n        _this.updateGestureState(movementDetection);\n\n        _this.updateGestureState(geometry);\n      } else {\n        _this.updateGestureState(_extends({}, getGenericPayload(_assertThisInitialized(_this), event), _this.getKinematics(values, event)));\n      }\n\n      _this.fireGestureHandler();\n    };\n\n    _this.onEnd = function () {\n      _this.state._active = false;\n\n      _this.updateGestureState(_extends({}, _this.getMovement(_this.state.values), {\n        velocities: [0, 0],\n        velocity: 0\n      }));\n\n      _this.fireGestureHandler();\n    };\n\n    return _this;\n  }\n\n  var _proto = ScrollRecognizer.prototype;\n\n  _proto.addBindings = function addBindings$1(bindings) {\n    addBindings(bindings, 'onScroll', this.handleEvent);\n  };\n\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Scroll hook.\r\n *\r\n * @param handler - the function fired every time the scroll gesture updates\r\n * @param [config={}] - the config object including generic options and scroll options\r\n */\n\n\nfunction useScroll(handler, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  var buildScrollConfig = useRef();\n\n  if (!buildScrollConfig.current) {\n    buildScrollConfig.current = memoizeOne(_buildScrollConfig, isEqual);\n  }\n\n  return useRecognizers({\n    scroll: handler\n  }, buildScrollConfig.current(config));\n}\n\nvar RE_NOT_NATIVE = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;\n\nfunction sortHandlers(handlers) {\n  var _native = {};\n  var handle = {};\n  var actions = new Set();\n\n  for (var key in handlers) {\n    if (RE_NOT_NATIVE.test(key)) {\n      actions.add(RegExp.lastMatch);\n      handle[key] = handlers[key];\n    } else {\n      _native[key] = handlers[key];\n    }\n  }\n\n  return [handle, _native, actions];\n}\n/**\r\n * @public\r\n *\r\n * The most complete gesture hook, allowing support for multiple gestures.\r\n *\r\n * @param {Handlers} handlers - an object with on[Gesture] keys containg gesture handlers\r\n * @param {UseGestureConfig} [config={}] - the full config object\r\n * @returns {(...args: any[]) => HookReturnType<Config>}\r\n */\n\n\nfunction useGesture(_handlers, config) {\n  if (config === void 0) {\n    config = {};\n  }\n\n  var _sortHandlers = sortHandlers(_handlers),\n      handlers = _sortHandlers[0],\n      nativeHandlers = _sortHandlers[1],\n      actions = _sortHandlers[2];\n\n  RecognizersMap.set('drag', DragRecognizer);\n  RecognizersMap.set('hover', MoveRecognizer);\n  RecognizersMap.set('move', MoveRecognizer);\n  RecognizersMap.set('pinch', PinchRecognizer);\n  RecognizersMap.set('scroll', ScrollRecognizer);\n  RecognizersMap.set('wheel', WheelRecognizer);\n  var mergedConfig = buildComplexConfig(config, actions);\n  var internalHandlers = {};\n  if (actions.has('onDrag')) internalHandlers.drag = includeStartEndHandlers(handlers, 'onDrag');\n  if (actions.has('onWheel')) internalHandlers.wheel = includeStartEndHandlers(handlers, 'onWheel');\n  if (actions.has('onScroll')) internalHandlers.scroll = includeStartEndHandlers(handlers, 'onScroll');\n  if (actions.has('onMove')) internalHandlers.move = includeStartEndHandlers(handlers, 'onMove');\n  if (actions.has('onPinch')) internalHandlers.pinch = includeStartEndHandlers(handlers, 'onPinch');\n  if (actions.has('onHover')) internalHandlers.hover = handlers.onHover;\n  return useRecognizers(internalHandlers, mergedConfig, nativeHandlers);\n}\n\nfunction includeStartEndHandlers(handlers, handlerKey) {\n  var startKey = handlerKey + 'Start';\n  var endKey = handlerKey + 'End';\n\n  var fn = function fn(state) {\n    var memo = undefined;\n    if (state.first && startKey in handlers) handlers[startKey](state);\n    if (handlerKey in handlers) memo = handlers[handlerKey](state);\n    if (state.last && endKey in handlers) handlers[endKey](state);\n    return memo;\n  };\n\n  return fn;\n}\n\nexport { addV, rubberbandIfOutOfBounds, subV, useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };","import React, {\n  FC,\n  ReactNode,\n  useState,\n} from 'react';\nimport { animated } from 'react-spring';\nimport { useDrag } from 'react-use-gesture';\n\ninterface IPosition {\n  start: number;\n  end: number;\n}\n\ninterface IProps {\n  width: number;\n  height: number;\n  brushWidth: number;\n  top?: number;\n  left?: number;\n  chart: () => ReactNode;\n  initialPosition?: IPosition;\n  onChange?: ({ start, end }: IPosition) => void;\n}\n\nconst Container: FC<{ width: number, height: number }> = ({\n  children,\n  height,\n  width,\n}) => <rect width={width}\n  height={height}\n  fill=\"#eee\"\n>{children}</rect>\n\n// @TODO resize handles...\nconst Brush: FC<IProps> = ({\n  onChange,\n  brushWidth,\n  width,\n  height,\n  top = 0,\n  left = 0,\n  chart,\n  initialPosition,\n}) => {\n  const start = initialPosition\n    ? { x: initialPosition.start, y: 0, w: brushWidth }\n    : { x: 0, y: 0, w: brushWidth };\n\n  const [{ x, y, w }, set] = useState(start);\n\n  // Set the drag hook and define component movement based on gesture data\n  const bounds = { top: 0, bottom: height, left: 0, right: width - w };\n\n  const bind = useDrag(({ movement: [mx, my] }) => {\n    onChange && onChange({ start: mx, end: mx + w })\n    set({ x: mx, y: 0, w })\n  },\n    {\n      initial: () => [x, y],\n      bounds,\n    });\n\n  const bindResizeLeft = useDrag((props) => {\n    const width = props._lastEventType === 'mousemove' ?\n      w - props.delta[0]\n      : w;\n    set({ x: props.movement[0], y, w: width });\n    onChange && onChange({ start: props.movement[0], end: y + width })\n  },\n    {\n\n      initial: () => [x, y],\n      bounds,\n    });\n\n  const bindResizeRight = useDrag((props) => {\n    const width = props._lastEventType === 'mousemove' ?\n      w + props.delta[0]\n      : w;\n    set({ x, y, w: width });\n    onChange && onChange({ start: x, end: y + width })\n  },\n    {\n\n      initial: () => [x, y],\n      bounds,\n    });\n\n  return (\n    <g transform={`translate(${left}, ${top})`}>\n      <Container width={width} height={height}>\n      </Container>\n      {chart()}\n\n      <animated.rect\n        width={w}\n        height={height}\n        fill=\"#aaeeff\"\n        {...bind()}\n        style={{\n          cursor: 'move',\n          opacity: 0.5,\n          x, y\n        } as any}\n      >\n\n      </animated.rect>\n      <animated.rect\n        {...bindResizeLeft()}\n        width={10} height={height}\n        style={{\n          x: x,\n          opacity: 0,\n          cursor: 'w-resize',\n          y,\n        } as any}\n      ></animated.rect>\n      <animated.rect\n        {...bindResizeRight()}\n        width={10} height={height}\n        style={{\n          x: x + w,\n          opacity: 0,\n          cursor: 'e-resize',\n          y,\n        } as any}\n      ></animated.rect>\n    </g >\n  )\n}\n\nexport default Brush;\n","// Be sure to include styles at some point, probably during your bootstrapping\nimport 'react-datasheet/lib/react-datasheet.css';\n\nimport { scaleTime } from 'd3-scale';\nimport React, {\n  FC,\n  useState,\n} from 'react';\n\nimport {\n  Card,\n  CardContent,\n  Grid,\n  Typography,\n} from '@material-ui/core';\n\nimport {\n  Base,\n  IAxes,\n} from '../../../src';\nimport Brush from '../../../src/components/Brush';\nimport Line from '../../../src/components/Line';\nimport { data3 } from '../../../test/fixtures';\nimport Layout from '../components/layout';\nimport SEO from '../components/seo';\n\nconst dateFormat = '%d-%b-%y';\n\nconst axis: IAxes = {\n  x: {\n    dateFormat,\n    scale: 'time',\n    width: 800,\n    height: 20,\n  },\n  y: {\n    label: 'TAB_VIEW_CREDITS',\n    numberFormat: 'd',\n    scale: 'log',\n    height: 200,\n    width: 20,\n  },\n};\n\nconst filterData = (scale: any, pos: { start: number, end: number }) => (data: any) => {\n  const x = scale(data.x);\n  return x >= pos.start && x <= pos.end;\n}\n\nconst { line, data } = data3[0];\nconst width = 800;\n\nconst LineExample: FC = () => {\n\n  const initialPosition = { start: 100, end: 200 };\n  const scale = scaleTime()\n    .domain([data[0].x, data[data.length - 1].x])\n    .range([0, width]);\n\n  const [brushedData, setBrushedData] = useState(data.filter(filterData(scale, initialPosition)));\n\n\n  const makeBrushedData = (pos: { start: number, end: number }) => {\n    setBrushedData(data.filter(filterData(scale, pos)));\n  }\n  return (\n    <Layout>\n      <SEO title=\"Line Chart\" description=\"\" />\n      <Typography variant=\"h2\">Brush</Typography>\n      <div>\n        <Grid container spacing={10}>\n          <Grid item xs={6}>\n            <Card>\n              <CardContent>\n                <Base\n                  width={width}\n                  height={400}>\n\n                  <Line\n                    axis={axis}\n                    label=\"brushed data\"\n                    line={line}\n                    width={width}\n                    left={0}\n                    animate={false}\n                    height={200}\n                    data={brushedData} />\n\n                  <Brush width={width}\n                    top={250}\n                    initialPosition={initialPosition}\n                    brushWidth={100}\n                    chart={() => <Line\n                      axis={axis}\n                      label=\"brushed data\"\n                      line={line}\n                      width={width}\n                      left={0}\n                      height={50}\n                      data={data} />}\n                    onChange={(pos) => makeBrushedData(pos)}\n                    height={50} />\n                </Base>\n              </CardContent>\n            </Card>\n          </Grid>\n\n        </Grid>\n      </div>\n    </Layout>\n  );\n};\n\nexport default LineExample;\n","import { curveCatmullRom } from 'd3-shape';\nimport { timeFormat } from 'd3-time-format';\n\nimport { ILineChartDataSet } from '../src';\n\nconst dateFormat = '%d-%b-%y';\nconst now = new Date();\nconst xs = new Array(100).fill('').map((_, i) => new Date(new Date().setDate(now.getDate() + i)))\nconst dateValues = xs.map((v) => ({\n  x: v, y: Math.random() * 1000,\n}));\n\nexport const data3: ILineChartDataSet<any>[] = [{\n  'label': 'rob Allocation',\n  'line': {\n    'curveType': curveCatmullRom,\n    'fill': { 'fill': 'rgba(11, 85, 167, 0.2)', 'show': true },\n    'show': true,\n    'stroke': 'rgb(11, 85, 167)',\n    'strokeDashArray': '0',\n    'strokeDashOffset': 0\n  },\n  'point':\n    { 'fill': '#000', 'radius': 4, 'show': true, 'stroke': '' },\n  'data': dateValues,\n}, {\n  'label': 'rob\\'',\n  'line': {\n    'curveType': curveCatmullRom,\n    'fill': { 'fill': 'rgba(11, 85, 167, 0.7)', 'show': true },\n    'show': true, 'stroke': '#000', 'strokeDashArray': '0', 'strokeDashOffset': 0\n  },\n  'point': { 'fill': '', 'radius': 0, 'show': false, 'stroke': '' },\n  'data': [\n    { x: new Date('2019-08-20T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-21T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-22T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-23T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-24T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-25T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-26T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-27T00:00:00.000Z'), y: 0 }]\n},\n{\n  'label': 'Their Allocation',\n  'line': {\n    'curveType': curveCatmullRom,\n    'fill': { 'fill': 'rgba(0, 169, 123, 0.2)', 'show': true },\n    'show': true, 'stroke': 'rgb(0, 169, 123)', 'strokeDashArray': '0', 'strokeDashOffset': 0\n  },\n  'point': { 'fill': '', 'radius': 0, 'show': false, 'stroke': '' }, 'data': [\n    { x: new Date('2019-08-20T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-21T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-22T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-23T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-24T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-25T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-26T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-27T00:00:00.000Z'), y: 0 }]\n}, {\n  'label': 'Theirs',\n  'line': {\n    'curveType': curveCatmullRom,\n    'fill': { 'fill': 'rgba(0, 169, 123, 0.7)', 'show': true },\n    'show': true, 'stroke': '#000', 'strokeDashArray': '0', 'strokeDashOffset': 0\n  },\n  'point': { 'fill': '', 'radius': 0, 'show': false, 'stroke': '' }, 'data': [\n    { x: new Date('2019-08-20T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-21T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-22T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-23T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-24T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-25T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-26T00:00:00.000Z'), y: 0 },\n    { x: new Date('2019-08-27T00:00:00.000Z'), y: 0 }]\n}];\n"],"sourceRoot":""}